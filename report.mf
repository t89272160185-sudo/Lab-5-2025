# Лабораторная работа №5. Переопределение методов Object для табулированных функций  
Студент: _____________________ (группа ________)  
Дисциплина: ООП, Java

## Введение
Цель работы — научиться корректно переопределять базовые методы `Object` (`toString`, `equals`, `hashCode`, `clone`) для собственных типов данных и убедиться в согласованности их поведения на примере табулированных функций. Задачи: реализовать текстовое представление точек и функций, обеспечить точное сравнение и вычисление хэш-кодов, выполнить глубокое клонирование для структур с вложенными объектами и проверить корректность на массивах и связных списках точек.

## Теоретическая часть
- `toString()` используется для человекочитаемого вывода; важно возвращать структуру данных в явном формате.  
- Контракт `equals`/`hashCode`: равные объекты обязаны иметь одинаковый хэш-код; для чисел с плавающей точкой используется сравнение по битам (`Double.doubleToLongBits`) без потери точности.  
- `clone()` и `Cloneable`: поверхностное копирование подходит для простых объектов, но контейнеры (`ArrayTabulatedFunction`, `LinkedListTabulatedFunction`) требуют глубокого копирования, чтобы изменения исходника не затрагивали клон.  
- Табулированная функция описывается упорядоченным набором точек `(x, y)` и линейной интерполяцией между ними; область определения ограничена крайними абсциссами.

## Метод и реализация
### Структура проекта
- `src/Main.java` — консольная проверка всех методов.  
- `src/functions/FunctionPoint.java` — точка функции.  
- `src/functions/ArrayTabulatedFunction.java` — хранение точек в массиве.  
- `src/functions/LinkedListTabulatedFunction.java` — двусвязный список точек.  
- `src/functions/TabulatedFunction.java` — интерфейс функции (теперь расширяет `Cloneable` и объявляет `clone()`).

### Ключевые решения
1. **toString**  
   - `FunctionPoint`: формат `(x; y)`.  
   - Табулированные функции: список точек в фигурных скобках `{(x1; y1), ...}`.
2. **equals**  
   - `FunctionPoint`: сравнение битовых представлений `double`.  
   - `ArrayTabulatedFunction` и `LinkedListTabulatedFunction`: быстрый путь для объектов того же класса (прямой доступ к полям/узлам) и универсальный путь через интерфейс `TabulatedFunction`. Размеры и каждая точка проверяются по битам.  
3. **hashCode**  
   - Точка: XOR разложенных на 2 `int` битов `double` координат.  
   - Функции: XOR всех хэш-кодов точек и числа точек (чтобы различать функции с/без промежуточных точек).  
4. **clone**  
   - `FunctionPoint`: достаточно поверхностного клона.  
   - `ArrayTabulatedFunction`: копируется сам объект и создаётся новый массив с клон-копиями точек.  
   - `LinkedListTabulatedFunction`: список «пересобирается» с новыми узлами и клон-копиями точек; кеш индекса сбрасывается.  
5. **Погрешности**: для проверок порядка по X используется `EPS = Math.ulp(1.0)`; поведение функции вне диапазона — `NaN`.

### Шаги запуска и проверки
1. Собрать и запустить (для JDK 17+):  
   ```bash
   javac -d out $(find src -name \"*.java\")\n   java -cp out Main\n   ```
2. В `Main` создаются одинаковые функции на массиве и списке, далее последовательно проверяются `toString`, симметрия `equals` между разными реализациями, согласованность `hashCode`, глубокое клонирование и неизменность клонов после модификации исходников.

## Результаты
Ожидаемый консольный вывод (значимые строки):
```
=== toString() ===
Array:      {(0.0; 0.0), (1.0; 1.0), (2.0; 4.0)}
LinkedList: {(0.0; 0.0), (1.0; 1.0), (2.0; 4.0)}

=== equals() across implementations ===
Array vs LinkedList: true
LinkedList vs Array: true
Array vs new Array:  true

=== hashCode() consistency ===
Array hash:      1048579
LinkedList hash: 1048579
Tweaked hash (+0.003 to y1): -1169278603

=== clone() deep copy ===
Original array after change: {(0.0; 10.0), (1.0; 1.0), (2.0; 4.0)}
Array clone preserved:       {(0.0; 0.0), (1.0; 1.0), (2.0; 4.0)}
Original list after change:  {(0.0; 0.0), (1.0; 1.0), (2.0; 8.0)}
List clone preserved:        {(0.0; 0.0), (1.0; 1.0), (2.0; 4.0)}
Clone equality check:
- arrayClone equals tweaked:     false
- listClone equals original list:false
```
Результаты подтверждают: строковое представление формируется корректно, `equals` симметричен между разными реализациями, `hashCode` меняется при малом изменении данных, а клоны остаются неизменными после правок оригиналов (глубокое копирование).

## Тестирование и проверка
- Ручной прогон `Main` демонстрирует все сценарии из задания: сравнение одинаковых и различающихся функций, вывод хэшей и клонов.  
- Дополнительно можно проверить граничные случаи: удаление точки при минимально допустимом количестве (должно бросать исключение), попытка добавить точку с совпадающим X (ожидается `InappropriateFunctionPointException`), вычисление `getFunctionValue` за пределами области (результат `NaN`).

## Выводы
Все требуемые методы `Object` переопределены: обеспечены читаемое представление, корректное сравнение и хэширование, глубокое клонирование для контейнеров. Реализация поддерживает интерфейсную совместимость (`TabulatedFunction` клонируем, методы работают между разными реализациями). Поведение функций устойчиво к изменениям данных и корректно обрабатывает ошибочные сценарии.

## Источники
1. Oracle Java Language Specification, разделы про `Object`, `Cloneable`, правила `equals`/`hashCode`.  
2. Документация `Double.doubleToLongBits` для точного сравнения `double`.
